# PA Report for 1-3 filename

### 解题构思

- 最初只想到进行最长公共子序列常规的动态规划即可，但是发现九成测之后有测试点超时，同时还存在空间爆炸的情况，于是考虑如何优化算法。
- 对空间复杂度的优化：常规动态规划调用函数，需要一个mn大小的巨大二维数组存储已经计算过的结果（不用这个大数组就会导致重复的计算同一个量，时间复杂度必然过高），于是想到可以反向从小向大扩散
- 因为我们知道计算len(s,t) (s1的前s位和s2的前t位的最长公共子序列长度)只需要另外三个量：len(s,t-1),len(s-1,t),len(s-1,t-1).我们知道数据的使用顺序，所以只需要定义两个m(或n) 大小的一维数组交替更新彼此即可，从而大大降低空间复杂度。
- 时间复杂度的优化：原始递归方法的优化是建立记忆功能，可以新开一个二维布尔数组记录是否曾经计算过这个值（或是原始值设置为-1，每次调用函数就进行判定），优化空间复杂度之后我们需要重新考虑如何优化时间复杂度。
- 注意到修改次数限制k较小，我们可以排除很大一部分不需要计算的区域。

>考虑如果按照最长公共子序列经典递归
>>向下进行得到一条从（n,m）到（0，0）的路径
>>这条路径只有在倾斜前进时会使值len(n,m)增大1,水平前进时数值不变

>由于修改次数k的上界限制，最长公共子序列长度会有一个下界限制
>>为了确定len(s,t)是否有着计算的必要，考虑路径经过点（s,t）时len(n,m)的最大值
>>最大值为min(n-s,m-t)+min(s,t)，这个值必须大于上界，经过数学化简可以确定有意义的计算范围，对于没意义的计算范围，就算他们在计算相邻位置的len值时被用到也直接忽略。

- 我们这样就极大地缩减了计算复杂度。

### 实现方法

1.**输入数据的预处理**

- 根据问题要求，如果 N（A的长度）小于 M（B的长度），则交换两个字符串以确保 A 不短于 B。
- 根据之前推导的数学表达式计算左右边界，以确定需要计算的数据范围。
- 代码使用两个一维数组 stage1 和 stage2 交替存储中间结果，用于动态规划计算最长公共子序列。

>计算len(i,j)时
>>字符 s1[i] 和 s2[j] 相等时，当前位置的值等于len(i,j)的值加一，若当前计算的位置有意义，斜下方位置必然也有意义，不需要用ass函数特判。
>>如果字符不相等，则使用 ass 函数来评估是否有必要计算另外两个直接相邻的位置。如果评估结果无意义，则意味着那个位置不需要计算，此时可以直接选择剩下的位置的值，因为如果len(i,j)有意义，len(i-1,j)和len(i,j-1)中至少有一个有意义。如果两个位置都有意义则取更大的值即可。

- 最长公共子序列长度：根据动态规划的结果，确定最长公共子序列的长度储存在那个数组中,具体取决于 n 的奇偶性，这是因为数组 stage1 和 stage2 交替使用。
- 最少修改次数判定：代码判断是否可以在不超过最大修改次数 K 的情况下将字符串 A 转化为字符串 B。这是通过比较 (m + n - 2 * len) 和 K 的大小来完成的。如果小于等于 K，则输出最少修改次数；否则输出 -1。


### 调试与微调&问题解决

- 边界计算时会出现数组越界，比如计算len(0,0)时会调用索引为-1的数组元素，显然会造成错误，所以人工特判将len(0,j)和len(i,0)都赋值为0.
- 对于范围上下界left和right，不应该都使用整数除法默认的下取整，其中的下界left应该采用上取整，这样才严格精确地确定了有意义的计算范围。

### 时间和空间复杂度估算

>空间复杂度
>>两个大小为m的交替存储数组
>>其他的原始数据等（相比可忽略不计）

***综上，空间复杂度大约为O(m)***

>时间复杂度
>>时间复杂度为k(上界，可能小于k)的计算循环n次

***综上，空间复杂度大约为O(nk)***
