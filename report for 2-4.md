# PA Report for 2-4 Triangulation

### 解题构思

- 规定算法已经在题目中给出，只需实现即可。
- 首先需要进行初步的数据处理，包括依据x轴坐标确定扫描顺序，以及确定每个点的类别(左端点，右端点，上端点，下断点)
- 开始按照算法过程开始扫描，按照情况分类开始执行对应方法。

### 实现方法
这段C++代码实现了三角抛分算法（Triangulation），用于将一个凸多边形划分成若干个三角形。以下是对代码各部分的详细解析：

1. **结构体定义：节点**
- `struct Point`: 表示一个点，包括横坐标 (`x`)、纵坐标 (`y`) 和节点在 `dot` 数组中的编号 (`index`)。
- `looper(long long int a)` ：处理节点索引循环，确保索引在数组范围内。这个函数通过检查索引a是否超出范围（大于n或小于1），来实现索引循环。如果a大于n，返回a-n；如果a小于1，返回a+n；否则返回a。

2. **全局变量：**
   - `Point dot[1100000]`: 用于存储二维点集。
   - `long long int poly[1100000]`: 用于存储点的类别（左右边界、上面、下面）。
   - `long long int addr[1100000]`: 用于存储扫描点的顺序。
   - `long long int n`: 顶点数。

3. **外积和内积计算函数：**
   - `outerproduct(long long int a, long long int b, long long int c)`: 计算三个点的普通外积。
   - `innerproduct(long long int a, long long int b, long long int c)`: 根据点的类别，保证内角被计算的外积函数。

4. **结构体定义：栈**

- `struct Stack`: 表示一个栈，包括一个固定大小的数组 `elements` 和栈顶索引 `topIndex`。
- `Stack() : topIndex(0) {}`：栈的构造函数，初始化栈顶索引为0。

- `void push(const Point& p)`：功能为栈的入栈操作。将给定的点p推入栈中，栈顶索引递增。

- `Point pop()`：功能为栈的出栈操作。将栈顶元素弹出，同时将栈顶索引递减，并返回弹出的元素。

- `Point top() const`：获取栈顶元素，但不出栈。

- `Point tip() const`：获取栈顶元素的前一个元素。

- `void clear()`:清空全栈。将栈顶索引设置为0，即清空栈的内容。

- `bool isEmpty() const`：判断栈是否为空。检查栈顶索引是否为0，如果是则说明栈为空。

- `long long int size() const`：获取栈的大小。返回栈顶索引，即栈的大小。

5. **初始化栈：**
   - `Stack myStack`: 用于存储抛分过程中的节点。

6. **主函数：**
   - 通过输入快速设置。
   - 读入节点数量 `n` 和点的坐标信息，同时确定最大和最小点的索引。
   - 通过从最小点索引min开始的归并过程，算法从最小点开始向两侧归并，直至上下同时到达最大点，得到扫描顺序数组 `addr`。构建扫描点的顺序数组 `addr`，并确定每个点的类别 `poly`。
   - 初始化栈，将最小点和次小点入栈。
   - 从左至右按照 `addr` 顺序开始扫描。
   - 根据点的类别进行扫描处理，在过程中输出划分方案。

### 调试与微调&问题解决

- 定义类型初始都习惯性地设置为int,忽略了问题中数据值较大，数据超过类型范围导致报错，后续都改为long long int后成功解决
- 情况2(a)为当栈顶元素为劣节点时（即栈顶元素、次顶元素、当前节点构成一个小于π的角时），这个三角形可被剖分。之后弹出，并重复上述剖分+出栈过程直到栈顶元素为优节点。最后入栈。但实际上如果栈中节点一直被弹出直至只剩下一个时栈顶元素仍然不是优节点时应该直接将当前节点入栈。
- 扫描到最后一个点即最大右节点时，可以直接进行输出，无需进行判定。

### 时间和空间复杂度估算

> 空间复杂度
>> 三个大小为n的存储数组
>> 一个站结构体实例中的大小为n的数组
>> 其他的原始数据等（相比可忽略不计）

***综上，空间复杂度大约为O(n)***

> 时间复杂度
>>一次从最小左节点索引min开始的归并，直至两侧汇合至最大右节点索引max，复杂度为O(n)
>> 每个点入栈出栈各一次，复杂度为O(n)

***综上，空间复杂度大约为O(n)***
