# PA Report for 1-1 Gift

### 解题构思

- 最初只想到进行深搜遍历即可，但是发现九成测之后有测试点超时，于是开始考虑如何优化算法。
- 最原始的深搜遍历复杂度为2的n次方，想到可以将数据等分为两半，分别进行遍历存储，之后针对后半段数据的每种可能，只需要进行一次搜索，就可以知道
有多少种与之兼容的前半段数据的选择。
- 遍历存下的后半段数据，将每种可能的选择方法数累加就可以得到可行方法总数。
- 用存储空间换取计算复杂度的优化

### 实现方法

1. **数据结构和全局变量**
   - 定义全局变量，如`P`（限制值）、`n`（数据集的大小）、`middle`（数据集一半的大小）、以及一些数组，如`cost_1`和`cost_2`用于存储原始数据，`save`和`enumerate`用于存储遍历得到的前半和后半数据，以及`total`和`total_enum`用于存储遍历个数。

2. **saving函数**
   - `saving`函数使用深度优先搜索（DFS）算法，通过递归遍历数据集的前半部分，计算每种组合的和，并将结果存储到`save`数组中。

3. **saving_enum函数**
   - `saving_enum`函数类似于`saving`函数，遍历后半数据的所有可能组合并将其保存到`enumerate`数组中。

4. **QuickSort函数**
   - `QuickSort`是前半数据的快速排序算法，用于对`save`数组中的前半数据进行排序。

5. **findranking函数**
   - `findranking`函数用于查找目标值在`save`数组中的排名。它采用了二分搜索算法，根据目标值找到它在`save`数组中的位置。

6. **主函数**
   - 读入输入数据，包括数据集的大小（`n`）和目标值（`P`），以及原始数据（`cost_1`和`cost_2`）。
   - 调用`saving`和`saving_enum`函数来生成前半和后半数据的所有可能组合。
   - 调用`QuickSort`函数对前半数据进行排序。
   - 遍历后半数据的每个可能情况，使用`findranking`函数查找目标值在前半数据中的排名，并将这些排名相加，从而得到总的匹配方法数。

### 调试与微调&问题解决

- 定义类型初始都习惯性地设置为int,忽略了问题中数据值较大，数据超过类型范围导致报错，后续都改为long long int后成功解决
- 子算法的实现过程中的小问题，短暂调试后成功解决

### 时间和空间复杂度估算

>空间复杂度
>>两个2^(n/2)次方的存储数组
>>其他的原始数据等（相比可忽略不计）

***综上，空间复杂度大约为O(2^(n/2))***

>时间复杂度
>>两个2^(n/2)次方的DFS深搜遍历
>>n*2^(n/2)的快速排序
>>n的二分搜索循环遍历2^(n/2)次

***综上，空间复杂度大约为O(n2^(n/2))***
