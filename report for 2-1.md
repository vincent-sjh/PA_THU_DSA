# PA Report for 2-1 Risk

### 解题构思

- 最初只想到进行循环遍历即可，但是发现复杂度爆炸导致的时间超时，于是开始考虑如何优化算法。
- 最原始的循环复杂度为O(mn)次方，注意到查询区间的左边界和右边界均单调不减，想到可以将数据维护为一个优先队列，针对每次查询，依据入队和出队的元素个数进行对应出入队操作，之后只需要返回队首元素，就可以知道本区间内最大值。
- 优先队列在入队一个值的时候将所有小于这个值的元素都替换为这个值，因为队列先入先出，当一个值的后入队的值大于自身时自身的值就不会再影响队列中的最大值。
- 用上面的方法存下一系列查询区间内的单日最大确诊数，如果针对每组pq都遍历一次这个数组进行计数，复杂度为O(nt),但进行一次O(nlogn)复杂度的排序之后就可以以O(tlogn)时间完成输出任务。
- 用存储空间换取计算复杂度的优化。

### 实现方法

1. **全局变量：**

   - `long long int n, t;`：全局变量，表示天数 (`n`) 和查询次数 (`t`)。
   - `long long int p[200000], q[200000], weak[1100005], tompute[1100005];`：数组，用于存储输入数据。
   - `int maxweak[1100005];`：数组，用于存储每日最大确诊病例数。
   - `Queue weakman;`：`Queue` 优先队列实例。
2. **优先队列结构体：**

   - 定义了 `Queue` 结构，用于保存值对 (`long long int, long long int`)。每个数对的first储存单日确诊数，second储存这个确诊数对应的天数。
   - 提供了一系列用于队列操作的函数。
   - `initQueue`方法用于将优先队列初始化，将前后索引都设置为0.
   - `isEmpty`方法确认队列是否为空。
   - `size`方法返回优先队列中元素个数。
   - `front`方法返回队首元素。
   - `rear`方法返回队尾元素。
   - `enqueue`方法负责将元素入队。优先队列在入队一个值的时候将所有小于这个值的元素都替换为这个值，因为队列先入先出，当一个值的后入队的值大于自身时自身的值就不会再影响队列中的最大值。所以入队时计算队列中比当前入队值小的元素并替换为当前值。
   - `dequeue`方法将指定数量的元素出队，如果出队结束后队列为空则重新初始化整个队列。
3. **二分搜索函数：**

   - `BinarySearch` 函数对 `maxweak` 数组执行二分搜索，以找到给定边界值的位置。
4. **qsort 的比较函数：**

   - `compare` 函数被用作 `qsort` 函数的比较函数。
5. **主函数：**

   - 读取输入，包括天数 (`n`)、每日确诊病例数 (`weak`) 和风险计算的阈值 (`tompute`)。
   - 程序初始化 `weakman` 队列，并计算每天的最大确诊病例数。
   - 使用 `qsort` 函数对 `maxweak` 数组进行排序。
   - 读取查询次数 (`t`) 的输入。
   - 对于每个查询，程序读取值 `p[i]` 和 `q[i]`，并输出这些值的二分搜索结果。
6. **优化：**

   - 代码使用优先队列队列 (`weakman`) 高效计算每天的最大确诊病例数。
   - 采用二分搜索在排序数组 (`maxweak`) 中查找位置，提供了风险计算的快速查找。

### 调试与微调&问题解决

- 定义类型初始都习惯性地设置为int,忽略了问题中数据值较大，数据超过类型范围导致报错，后续都改为long long int后成功解决
- 本题m,p,q三种数据范围极大，除了上一条之外，可以在读入的时候就进行清洗，比如i-mi的值小于1的时候就规定为1,p与q的值过大无意义时同理。
- 入队出队时的边界情况处理。

### 时间和空间复杂度估算

> 空间复杂度
>
>> 三个大小为n的存储数组
>> 一个优先队列实例中的大小为n的数组
>> 其他的原始数据等（相比可忽略不计）
>>

***综上，空间复杂度大约为O(n)***

> 时间复杂度
>
>> 每个队列中的元素都入队出队各一次，复杂度为O(n)
>> 对maxweak数组的排序，复杂度为O(nlogn)
>> 二分搜索循环遍历t次,复杂度为O(tlogn)
>>

***综上，空间复杂度大约为O((n+t)logn)***
